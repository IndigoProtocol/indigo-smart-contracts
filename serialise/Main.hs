{-# LANGUAGE NamedFieldPuns #-}
{-# LANGUAGE OverloadedStrings #-}

module Main (main) where

import Cardano.Api.SerialiseTextEnvelope (textEnvelopeToJSON, writeFileTextEnvelope)
import qualified Cardano.Api.Shelley as Script
import Codec.Serialise (serialise)
import Control.Monad (forM_, void)
import qualified Data.ByteString.Lazy as BSL
import qualified Data.ByteString.Short as SBS
import Data.Text.Lazy (Text)
import qualified Data.Text.Lazy as T
import Data.Text.Lazy.Encoding (decodeLatin1)
import qualified Data.Text.Lazy.IO as TIO
import Indigo.Contracts.CDP.OnChain (cdpCreatorScriptCTL, cdpScriptCTL, iAssetPolicyScriptCTL)
import Indigo.Contracts.Collector.OnChain (collectorScriptCTL)
import Indigo.Contracts.Governance.Execute.OnChain (executeScriptCTL)
import Indigo.Contracts.Governance.Gov.OnChain (govScriptCTL)
import Indigo.Contracts.Governance.Poll.OnChain (pollManagerScriptCTL, pollScriptCTL)
import Indigo.Contracts.Governance.VersionRegistry.OnChain (versionRecordTokenPolicyScriptCTL, versionRegistryScriptCTL)
import Indigo.Contracts.Liquidity.OnChain (liquidityScriptCTL)
import Indigo.Contracts.Oracle.OnChain (oracleScriptCTL)
import Indigo.Contracts.StabilityPool.OnChain (stabilityPoolScriptCTL)
import Indigo.Contracts.Staking.OnChain (stakingScriptCTL)
import Indigo.Contracts.Treasury.OnChain (treasuryScriptCTL)
import Indigo.Data.Token (authTokenCTL)
import Options.Applicative (ParserInfo, execParser, fullDesc, help, helper, info, long, metavar, progDesc, showDefault, strOption, switch, value)
import Options.Applicative.Common (Parser)
import Plutus.V2.Ledger.Api (Script)
import System.Directory (createDirectoryIfMissing)
import System.FilePath ((</>))

data CliOptions = CliOptions
  { optsFolder :: FilePath,
    optsOutputFfisFlag :: Bool
  }

cliOptionsParser :: Parser CliOptions
cliOptionsParser =
  CliOptions
    <$> strOption
      ( long "out"
          <> metavar "FOLDER"
          <> showDefault
          <> value "scripts"
          <> help "Folder for saving scripts"
      )
    <*> switch
      ( long "export-purescript-ffis"
          <> showDefault
          <> help
            "Whether to serialise the scripts as Purescript's FFI \
            \modules for use in offchain"
      )

opts :: ParserInfo CliOptions
opts =
  info
    cliOptionsParser
    (fullDesc <> progDesc "Serialise scripts to a FOLDER")

-- | Convert a 'Script' to a 'cardano-api' script
toCardanoApiScript :: Script -> Script.Script Script.PlutusScriptV2
toCardanoApiScript =
  Script.PlutusScript Script.PlutusScriptV2
    . Script.PlutusScriptSerialised
    . SBS.toShort
    . BSL.toStrict
    . serialise

saveScriptRepr :: FilePath -> Script -> IO ()
saveScriptRepr filename script = void $ writeFileTextEnvelope filename Nothing $ toCardanoApiScript script

saveFfiRepr :: FilePath -> Text -> Script -> IO ()
saveFfiRepr filename varName script = TIO.writeFile filename fileContents
  where
    scriptJson :: Text
    scriptJson = decodeLatin1 $ textEnvelopeToJSON Nothing $ toCardanoApiScript script
    fileContents :: Text
    fileContents =
      "/* Automatically generated by serialise-contract executable in smart-contracts */\n"
        <> varName
        <> " = "
        <> scriptJson
        <> ";\n"
        <> "exports._"
        <> varName
        <> " = JSON.stringify("
        <> varName
        <> ");\n"

-- Note: does not include `mkUpgradeMintingPolicyScriptCTL`
scripts :: [(FilePath, Script)]
scripts =
  [ -- CDP
    ("cdp.plutus", cdpScriptCTL),
    ("cdp_creator.plutus", cdpCreatorScriptCTL),
    ("iasset_policy.plutus", iAssetPolicyScriptCTL),
    -- Collector
    ("collector.plutus", collectorScriptCTL),
    -- Governance.Execute
    ("execute.plutus", executeScriptCTL),
    -- Governance.Gov
    ("gov.plutus", govScriptCTL),
    -- Governance.Poll
    ("poll.plutus", pollScriptCTL),
    ("poll_manager.plutus", pollManagerScriptCTL),
    -- Governance.VersionRegistry
    ("version_record_token_policy.plutus", versionRecordTokenPolicyScriptCTL),
    ("version_registry.plutus", versionRegistryScriptCTL),
    -- Liquidity
    ("liquidity.plutus", liquidityScriptCTL),
    -- Oracle
    ("oracle.plutus", oracleScriptCTL),
    -- StabilityPool
    ("stability_pool.plutus", stabilityPoolScriptCTL),
    -- Staking
    ("staking.plutus", stakingScriptCTL),
    -- Treasury
    ("treasury.plutus", treasuryScriptCTL),
    -- Auth token policy
    ("auth_token_policy.plutus", authTokenCTL)
  ]

-- Equivalent to association map above, but used for creating the Purescript
-- FFI modules used by the bots.
scriptsFfi :: [(FilePath, Text, Script)]
scriptsFfi =
  [ -- CDP
    ("CDPValidator.js", "cdpValidator", cdpScriptCTL),
    ("CDPCreatorValidator.js", "cdpCreatorValidator", cdpCreatorScriptCTL),
    ("IAssetToken.js", "iAssetTokenPolicy", iAssetPolicyScriptCTL),
    -- Collector
    ("CollectorValidator.js", "collectorValidator", collectorScriptCTL),
    -- Governance.Execute
    ("ExecuteValidator.js", "executeValidator", executeScriptCTL),
    -- Governance.Gov
    ("GovernanceValidator.js", "governanceValidator", govScriptCTL),
    -- Governance.Poll
    ("PollValidator.js", "pollValidator", pollScriptCTL),
    ("PollManagerValidator.js", "pollManagerValidator", pollManagerScriptCTL),
    -- Governance.VersionRegistry
    ("VersionRecordToken.js", "versionRecordTokenPolicy", versionRecordTokenPolicyScriptCTL),
    ("VersionRegistry.js", "versionRegistryValidator", versionRegistryScriptCTL),
    -- Liquidity
    ("LiquidityValidator.js", "liquidityValidator", liquidityScriptCTL),
    -- Oracle
    ("OracleValidator.js", "oracleValidator", oracleScriptCTL),
    -- StabilityPool
    ("StabilityPoolValidator.js", "stabilityPoolValidator", stabilityPoolScriptCTL),
    -- Staking
    ("StakingValidator.js", "stakingValidator", stakingScriptCTL),
    -- Treasury
    ("TreasuryValidator.js", "treasuryValidator", treasuryScriptCTL),
    -- Auth token policy
    ("AuthToken.js", "authTokenPolicy", authTokenCTL)
  ]

main :: IO ()
main = do
  CliOptions {optsFolder, optsOutputFfisFlag} <- execParser opts
  createDirectoryIfMissing False optsFolder
  if optsOutputFfisFlag
    then forM_ scriptsFfi $ \(jsFilename, varName, script) -> do
      let path = optsFolder </> jsFilename
      putStrLn $ "Saving " ++ path
      saveFfiRepr path varName script
    else forM_ scripts $ \(plutusFilename, script) -> do
      let path = optsFolder </> plutusFilename
      putStrLn $ "Saving " ++ path
      saveScriptRepr path script
